**AetherCL**

---

AetherCL ist eine GPU-Treiber-Simulations-Engine mit echter OpenCL-Interop, die Host‚ÜîGPU-Transfers, Kernel-Dispatch und Matrixoperationen realit√§tsnah abbildet. Ideal f√ºr Forschung, Deep-Learning-Prototyping und GPU-Architektursimulation. Plattform√ºbergreifend, erweiterbar, bildungstauglich.

---

### üìò Ausf√ºhrliche `README.md` (Version 1.0, inklusive Diagramm-GIF-Platzhalter)

# AetherCL ‚Äì Simulierte GPU-Engine mit OpenCL-Interop

**AetherCL** ist eine experimentelle, modulare C-basierte GPU-Treiber-Simulation mit echter Host‚ÜîGPU-Speicherinteraktion via OpenCL. Sie dient als Forschungssystem f√ºr Deep Learning, GPU-Architekturverst√§ndnis und realistische Prototyping-Szenarien ‚Äì z.‚ÄØB. f√ºr Matrixoperationen, Kernel-Simulation oder Speicherverifikation.

---

## üîç Features

- ‚úÖ Simulierte GPU-Speicherallokation (Host malloc + OpenCL Buffers)
- ‚úÖ OpenCL-basierte Host‚ÜíGPU‚ÜíHost Transfers
- ‚úÖ Matrixmultiplikation auf CPU mit echten GPU-Buffern
- ‚úÖ Asynchrones Readback mit `clSetEventCallback`
- ‚úÖ R√ºckgabe von Ergebnispuffern an Python √ºber ctypes
- ‚úÖ Modularer Aufbau mit klarer Host-/GPU-Trennung
- ‚úÖ Kompatibel mit Windows, Linux (macOS optional)
- ‚úÖ Ideal als LLM-Beschleuniger- oder Custom-Treiber-Basis

---

## üß† Zielsetzung

AetherCL richtet sich an:

- AI/ML-Forscher, die eigene Deep Learning Engines aufbauen
- Studierende, die GPU-Architektur realit√§tsnah verstehen wollen
- Entwickler, die OpenCL-basiertes Speicher- und Kernelmanagement simulieren
- Prototyping von Speicherpipelines, MMIO-Systemen, simulierten Dispatch-Systemen

---

## üß™ Beispiel: Matrixmultiplikation via `simulated_matrix_multiply`

```python
A = np.random.rand(5, 4)
B = np.random.rand(4, 6)
C_addr = gpu.simulated_matrix_multiply(mmap_ptr_a, mmap_ptr_b, size_a, size_b, shape_a, shape_b)
C = gpu.read_data(C_addr, shape=(5, 6), dtype=np.float64)
```

![Architektur-Diagramm](docs/aethercl_architecture.png)

> üí° *Die Matrixmultiplikation erfolgt CPU-seitig, aber √ºber echte OpenCL-GPU-Puffer, mit sp√§terem asynchronem Readback!*

---

## üìê Architektur

```plaintext
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        Host: Python (ctypes)
‚îÇ  numpy array ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
                    ‚ñº
           [simulated_kernel_write]
                    ‚îÇ
                    ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ Host Malloc Memory ‚îÇ (simuliert mmap)
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚ñº
        [write_to_gpu ‚Üí clEnqueueWriteBuffer]
                    ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ OpenCL GPU Buffer (A) ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ...
        [submit_command ‚Üí CPU-MatMul]
                         ...
        [clEnqueueReadBuffer ‚Üí callback]
                    ‚ñº
           [simulated_kernel_read]
                    ‚ñº
           Host-Puffer ‚Üí NumPy

```

---

## üîß Build

### Voraussetzungen

- OpenCL SDK (z.‚ÄØB. Intel, AMD, POCL, NVIDIA)
- GCC oder MSVC
- Python 3.12 mit `ctypes`
- Optional: `numpy` f√ºr die Python-Interaktion

### Kompilieren (Windows/GCC Beispiel)

```bash
gcc -I. -L. -shared -o simulated_driver.dll simulated_driver.c -lOpenCL -static-libgcc -static-libstdc++ -Wl,--export-all-symbols
```

---

## üß™ Testen mit Python

```bash
python app.py
```

> Die Ausgabe zeigt detailreich den Ablauf jeder GPU-Simulation ‚Äì von Allokation √ºber Matrixmultiplikation bis zum Readback.
```
Versuche, simulierten Treiber zu laden von: G:\amd LLM Treiber code\simulated_driver.dll
Simulierter Treiber erfolgreich geladen.
C-Funktionssignaturen erfolgreich definiert.
Treiber-Shutdown-Funktion f√ºr atexit registriert.

--- Start des Hauptprogramms (mit mmap-basiertem Treiber) ---
Initialisiere GPUManager...
Simuliere GPU-Anzahl (fest auf 1).
Manager: 1 GPU(s) gefunden (simuliert).
Simuliere CU-Anzahl f√ºr GPU 0 (fest auf 2560).
Manager: Erstelle GPU-Objekt f√ºr Index 0 mit 2560 CUs.
GPU Objekt 0 erstellt (CUs: 2560).
GPUManager Initialisierung abgeschlossen.

Verf√ºgbare GPUs im Manager: 1

--- Operationen auf GPU 0 ---
GPU 0: Fordere Initialisierung √ºber Treiber an...
initialize_gpu: Initialisierung erfolgreich (Context: 00000081a47f8980, Queue: 00000081a2da79e0).
GPU 0: Treiber-Initialisierung erfolgreich.

Host: Erstelle Matrizen...
Host: Matrix A (shape=(5, 4), dtype=float64)
Host: Matrix B (shape=(4, 6), dtype=float64)

Host: Alloziere Speicher auf GPU f√ºr Matrizen...
GPU 0: Fordere Allokation von 160 Bytes an...
[C Driver][simulated_kernel_allocate] GPU 0 - Simuliert (malloc) 160 bytes bei 00000081a1fb2620
GPU 0: Allokation erfolgreich, Adresse erhalten: 556768372256
GPU 0: Fordere Allokation von 192 Bytes an...
[C Driver][simulated_kernel_allocate] GPU 0 - Simuliert (malloc) 192 bytes bei 00000081a1fba5b0
GPU 0: Allokation erfolgreich, Adresse erhalten: 556768404912
Host: 'GPU'-Adressen erhalten: A=556768372256, B=556768404912

Host: Schreibe Daten in den GPU-Speicher...
GPU 0: Fordere Schreiben von 160 Bytes an Adresse 556768372256 an...
[C Driver][simulated_kernel_write] Kopiere 160 Bytes von Host-Quelle 00000081a2e951b0 nach Host-Ziel 00000081a1fb2620 (addr 556768372256)
[C Driver]   Host-zu-Host-Kopie (simulated_kernel_write) abgeschlossen.
GPU 0: Schreibanforderung gesendet.
GPU 0: Fordere Schreiben von 192 Bytes an Adresse 556768404912 an...
[C Driver][simulated_kernel_write] Kopiere 192 Bytes von Host-Quelle 00000081a5576f90 nach Host-Ziel 00000081a1fba5b0 (addr 556768404912)
[C Driver]   Host-zu-Host-Kopie (simulated_kernel_write) abgeschlossen.
GPU 0: Schreibanforderung gesendet.
Host: Daten erfolgreich zur GPU geschrieben (simuliert).

Host: Starte Kernel 'matrix_multiply' auf GPU...
GPU 0: Fordere Ausf√ºhrung von Kernel 'matrix_multiply' an...
[C Driver] simulated_matrix_multiply gestartet f√ºr GPU 0.
[C Driver][sim_matmul] Matrix A Shape: (5, 4), Size: 160
[C Driver][sim_matmul] Matrix B Shape: (4, 6), Size: 192
[C Driver][sim_matmul] Ergebnis Matrix C Shape: (5, 6), Size: 240
[C Driver][allocate_gpu_memory] OpenCL Buffer erstellt (handle=00000081a54d2250), Size=160
[C Driver][allocate_gpu_memory] OpenCL Buffer erstellt (handle=00000081a54d2d90), Size=192
[C Driver][allocate_gpu_memory] OpenCL Buffer erstellt (handle=00000081a5512750), Size=240
[C Driver][sim_matmul] √úbertrage Daten von Host nach GPU...
[C Driver][write_to_gpu] Starte clEnqueueWriteBuffer: 160 Bytes von Host 00000081a1fb2620 nach GPU 00000081a54d2250
[C Driver][write_to_gpu] Erfolgreich 160 Bytes von Host 00000081a1fb2620 nach GPU Puffer 00000081a54d2250 geschrieben
[C Driver][write_to_gpu] Starte clEnqueueWriteBuffer: 192 Bytes von Host 00000081a1fba5b0 nach GPU 00000081a54d2d90
[C Driver][write_to_gpu] Erfolgreich 192 Bytes von Host 00000081a1fba5b0 nach GPU Puffer 00000081a54d2d90 geschrieben
[C Driver][sim_matmul] Daten√ºbertragung Host->GPU abgeschlossen.
[C Driver][sim_matmul] Sende Matrixmultiplikations-Befehl (Simulation)...
[C Driver][submit_command] Starte CPU-Matrixmultiplikation (Simulation)...
[C Driver][submit_command] CPU-Matrixmultiplikation abgeschlossen.
[C Driver][submit_command] Matrixmultiplikations-Simulation erfolgreich abgeschlossen.
[C Driver][sim_matmul] Matrixmultiplikations-Befehl abgeschlossen (Status: 1).
[C Driver][sim_matmul] Starte asynchronen Readback GPU Puffer C -> Host...
[C Driver]   Host-Ergebnispuffer allokiert bei 00000081a1fbb690
[C Driver]   Non-blocking Read eingereiht (Event: 00000081a46fc2b0). Setze Callback.
[C Driver]   Callback registriert f√ºr Event 00000081a46fc2b0.
[C Driver]   Warte auf Beendigung der Command Queue (clFinish)...
[C Driver][Callback GPU 0] Readback event (00000081a46fc2b0) abgeschlossen. Status: CL_SUCCESS (0)
[C Driver][Callback GPU 0] Daten lesen in Host-Puffer abgeschlossen.
[C Driver][Callback GPU 0] Callback beendet.
[C Driver]   Command Queue beendet (Status: CL_SUCCESS).
[C Driver][sim_matmul] Bereinige GPU Puffer...
[C Driver][free_gpu_memory] OpenCL Buffer freigegeben (handle=00000081a54d2250)
[C Driver][free_gpu_memory] OpenCL Buffer freigegeben (handle=00000081a54d2d90)
[C Driver][free_gpu_memory] OpenCL Buffer freigegeben (handle=00000081a5512750)
[C Driver][sim_matmul] Matrixmultiplikation erfolgreich. Gebe Host-Adresse zur√ºck: 556768409232 (00000081a1fbb690)
GPU 0: Kernel 'matrix_multiply' erfolgreich (simuliert), Ergebnisadresse: 556768409232
Host: Kernel beendet. Ergebnis an GPU-Adresse: 556768409232

Host: Lese Ergebnis von GPU zur√ºck zum Host...
GPU 0: Fordere Lesen von 240 Bytes von Adresse 556768409232 an...
[C Driver][simulated_kernel_read] Kopiere 240 Bytes von Host Addr 556768409232 (00000081a1fbb690) nach Python Dest 00000081a48fb4f0
[C Driver]   Gebe Host Ergebnispuffer frei bei 00000081a1fbb690
[C Driver]   Lesen/Kopieren von Host abgeschlossen.
GPU 0: Leseanforderung abgeschlossen.

--- Ergebnis der Matrixmultiplikation (vom simulierten Treiber berechnet/gelesen) ---
Shape: (5, 6), Dtype: float64
[[0.72470531 0.53853531 1.04054047 0.6923406  0.81253766 1.16930091]
 [0.95457385 0.40580491 1.08629638 0.93634127 0.88719397 0.97491993]
 [0.76286833 0.31892414 0.92117509 0.91012526 0.80013112 0.99433272]
 [1.91374926 0.9449003  2.30844999 1.97723782 1.65517081 2.214666  ]
 [1.25484958 0.4630622  1.4020248  1.42356855 1.00587981 1.29352593]]

Host: Verifiziere mit NumPy...
VERIFIKATION ERFOLGREICH: Ergebnis vom Treiber stimmt mit NumPy √ºberein.

Host: Gebe Speicher auf GPU frei...
GPU 0: Fordere Freigabe von 240 Bytes an Adresse 556768409232 an...
[C Driver][simulated_kernel_free] GPU 0 - Simuliert (free) 240 bytes bei 00000081a1fbb690
```

## üìÅ Projektstruktur

```plaintext
‚îú‚îÄ‚îÄ simulated_driver.c         # Simulierter C-Treiber mit OpenCL-Bindung
‚îú‚îÄ‚îÄ app.py                     # Python Test Harness
‚îú‚îÄ‚îÄ README.md                  # Diese Datei
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ aethercl_architecture.png   # Diagramm (optional auch als GIF)
‚îî‚îÄ‚îÄ simulated_driver.dll       # Kompilierte Shared Library
```

---

## üöÄ N√§chste Schritte (Vision)

- Echte GPU-Matrixkernel mit OpenCL C
- Simuliertes MMIO-Interface mit `mmap`
- Integration eines Memory Schedulers (z.‚ÄØB. f√ºr LLM)
- Erweiterung um Softmax, Conv2D, ReLU etc.
- Komplettes Command Dispatch System mit Scheduler-Logik

---

## ü§ù Lizenz

MIT License ‚Äì Frei verwendbar f√ºr Lehre, Forschung, Entwicklung.

---

## üß† Inspiration

Dieses Projekt entstand aus der Vision, GPU-Verhalten auf systemnaher Ebene verst√§ndlich und kontrolliert zu simulieren ‚Äì als Lernhilfe, Experimentierplattform und Br√ºckentechnologie f√ºr AI-Systeme jenseits etablierter Frameworks wie CUDA oder TensorFlow.

---

## üì∑ Beispiel-Visualisierung



---

